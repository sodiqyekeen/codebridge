namespace CodeBridge.Core.Templates;

/// <summary>
/// Provides TypeScript HTTP client template with advanced features:
/// - CSRF token management with caching and expiry
/// - Enhanced token refresh with cooldown and retry limits
/// - File upload/download utilities
/// - Session ID extraction and attachment
/// - RFC 7807 Problem Details support
/// </summary>
public static class HttpClientTemplate
{
    public static string GetTemplate(bool includeCsrf, bool includeAuth, bool includeFileOperations)
    {
        var template = @"// Auto-generated HTTP Client
// DO NOT EDIT - This file is generated by CodeBridge

export interface HttpClientConfig {
  baseUrl: string;
  timeout?: number;
  headers?: Record<string, string>;
  onUnauthorized?: () => void | Promise<void>;
  onForbidden?: () => void | Promise<void>;
  csrf?: CsrfConfig;
  auth?: AuthConfig;
}

export interface CsrfConfig {
  enabled: boolean;
  tokenEndpoint?: string;
  tokenExpiry?: number; // milliseconds
}

export interface AuthConfig {
  getAccessToken?: () => string | null | Promise<string | null>;
  getRefreshToken?: () => string | null | Promise<string | null>;
  refreshEndpoint?: string;
  onTokenRefreshed?: (accessToken: string, refreshToken?: string) => void | Promise<void>;
  extractSessionId?: boolean;
}

export interface FileResult {
  data: Blob;
  filename?: string;
  contentType?: string;
}

export interface ProblemDetails {
  type?: string;
  title?: string;
  status?: number;
  detail?: string;
  instance?: string;
  errors?: Record<string, string[]>;
}

export class HttpClientError extends Error {
  constructor(
    message: string,
    public statusCode?: number,
    public problemDetails?: ProblemDetails,
    public response?: Response
  ) {
    super(message);
    this.name = 'HttpClientError';
  }
}

";

        if (includeCsrf)
        {
            template += GetCsrfTokenManagerTemplate();
        }

        template += GetCoreHttpClientTemplate(includeCsrf, includeAuth);

        if (includeFileOperations)
        {
            template += GetFileOperationsTemplate();
        }

        return template;
    }

    private static string GetCsrfTokenManagerTemplate()
    {
        return @"
/**
 * Manages CSRF tokens with caching and automatic expiry.
 * Implements double-submit cookie pattern for CSRF protection.
 */
class CsrfTokenManager {
  private currentToken: string | null = null;
  private tokenExpiry: number | null = null;
  private fetchPromise: Promise<string | null> | null = null;

  constructor(
    private readonly config: CsrfConfig,
    private readonly baseUrl: string
  ) {}

  /**
   * Gets a valid CSRF token, fetching a new one if necessary.
   * @param force - Force fetch a new token even if current one is valid
   */
  async getToken(force = false): Promise<string | null> {
    if (!this.config.enabled) {
      return null;
    }

    // Return cached token if still valid
    if (!force && this.isTokenValid()) {
      return this.currentToken;
    }

    // Reuse existing fetch promise to prevent concurrent requests
    if (this.fetchPromise) {
      return this.fetchPromise;
    }

    this.fetchPromise = this.fetchNewToken();
    
    try {
      const token = await this.fetchPromise;
      return token;
    } finally {
      this.fetchPromise = null;
    }
  }

  private async fetchNewToken(): Promise<string | null> {
    try {
      const endpoint = this.config.tokenEndpoint ?? '/api/csrf/token';
      const response = await fetch(`${this.baseUrl}${endpoint}`, {
        method: 'GET',
        credentials: 'include',
      });

      if (!response.ok) {
        console.error('Failed to fetch CSRF token:', response.statusText);
        return null;
      }

      const data = await response.json();
      this.currentToken = data.token ?? data.csrfToken ?? null;
      
      const expiryMs = this.config.tokenExpiry ?? 3600000; // Default 1 hour
      this.tokenExpiry = Date.now() + expiryMs;

      return this.currentToken;
    } catch (error) {
      console.error('Error fetching CSRF token:', error);
      return null;
    }
  }

  private isTokenValid(): boolean {
    return (
      this.currentToken !== null &&
      this.tokenExpiry !== null &&
      Date.now() < this.tokenExpiry
    );
  }

  clearToken(): void {
    this.currentToken = null;
    this.tokenExpiry = null;
  }
}

";
    }

    private static string GetCoreHttpClientTemplate(bool includeCsrf, bool includeAuth)
    {
        var authFields = includeAuth ? @"
  // Token refresh protection
  private isRefreshing = false;
  private refreshPromise: Promise<void> | null = null;
  private lastRefreshAttempt = 0;
  private readonly refreshCooldownMs = 5000; // 5 seconds
  private refreshAttemptCount = 0;
  private readonly maxRefreshAttempts = 3;
  private sessionId: string | null = null;" : "";

        var csrfField = includeCsrf ? @"
  private csrfManager: CsrfTokenManager;" : "";

        var csrfInit = includeCsrf ? @"
    this.csrfManager = new CsrfTokenManager(config.csrf ?? { enabled: false }, config.baseUrl);" : "";

        var authInit = includeAuth ? @"
    
    // Extract session ID from initial token if available
    if (config.auth?.extractSessionId && config.auth.getAccessToken) {
      const token = await Promise.resolve(config.auth.getAccessToken());
      if (token) {
        this.sessionId = this.extractSessionIdFromToken(token);
      }
    }" : "";

        return $@"
/**
 * Core HTTP client with automatic retry, error handling, and authentication support.
 */
class HttpClient {{
  private config: HttpClientConfig;{authFields}{csrfField}

  constructor(config: HttpClientConfig) {{
    this.config = config;{csrfInit}
  }}

  async request<TResponse = any>(
    method: string,
    path: string,
    options?: {{
      body?: any;
      headers?: Record<string, string>;
      queryParams?: Record<string, any>;
      requiresAuth?: boolean;
      isFileUpload?: boolean;
      isFileDownload?: boolean;
    }}
  ): Promise<TResponse> {{
    const url = this.buildUrl(path, options?.queryParams);
    const headers = await this.buildHeaders(method, options?.headers, options?.isFileUpload, options?.requiresAuth);

    let body: any;
    if (options?.isFileUpload) {{
      // For file uploads, body should already be FormData
      // Don't set Content-Type - browser will set it with boundary
      body = options.body;
    }} else if (options?.body) {{
      body = JSON.stringify(options.body);
    }}

    const requestInit: RequestInit = {{
      method,
      headers,
      body,
      credentials: 'include',
    }};

    if (this.config.timeout) {{
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), this.config.timeout);
      requestInit.signal = controller.signal;

      try {{
        return await this.executeRequest<TResponse>(url, requestInit, options);
      }} finally {{
        clearTimeout(timeout);
      }}
    }}

    return this.executeRequest<TResponse>(url, requestInit, options);
  }}

  private async executeRequest<TResponse>(
    url: string,
    requestInit: RequestInit,
    options?: {{ requiresAuth?: boolean; isFileDownload?: boolean }}
  ): Promise<TResponse> {{
    try {{
      let response = await fetch(url, requestInit);

      // Handle 401 with token refresh
      if (response.status === 401 && options?.requiresAuth && this.config.auth?.refreshEndpoint) {{
        const refreshed = await this.refreshToken();
        if (refreshed) {{
          // Retry with new token
          const newHeaders = await this.buildHeaders(
            requestInit.method ?? 'GET',
            requestInit.headers as Record<string, string>
          );
          response = await fetch(url, {{ ...requestInit, headers: newHeaders }});
        }} else {{
          await this.config.onUnauthorized?.();
          throw new HttpClientError('Unauthorized', 401);
        }}
      }}

      // Handle 403 Forbidden
      if (response.status === 403) {{
        await this.config.onForbidden?.();
        throw new HttpClientError('Forbidden', 403);
      }}

      // Handle file downloads
      if (options?.isFileDownload && response.ok) {{
        const blob = await response.blob();
        const filename = this.extractFilename(response);
        const contentType = response.headers.get('Content-Type') ?? undefined;

        return {{ data: blob, filename, contentType }} as any;
      }}

      // Handle non-OK responses
      if (!response.ok) {{
        await this.handleErrorResponse(response);
      }}

      // Parse JSON response
      const contentType = response.headers.get('Content-Type');
      if (contentType?.includes('application/json')) {{
        return await response.json();
      }}

      // For non-JSON responses (e.g., 204 No Content)
      return null as any;
    }} catch (error) {{
      if (error instanceof HttpClientError) {{
        throw error;
      }}

      if (error instanceof DOMException && error.name === 'AbortError') {{
        throw new HttpClientError('Request timeout');
      }}

      throw new HttpClientError(
        error instanceof Error ? error.message : 'Network error',
        undefined,
        undefined,
        undefined
      );
    }}
  }}

  private buildUrl(path: string, queryParams?: Record<string, any>): string {{
    const baseUrl = this.config.baseUrl.replace(/\/$/, '');
    const normalizedPath = path.startsWith('/') ? path : `/${{path}}`;
    let url = `${{baseUrl}}${{normalizedPath}}`;

    if (queryParams) {{
      const params = new URLSearchParams();
      Object.entries(queryParams).forEach(([key, value]) => {{
        if (value !== undefined && value !== null) {{
          if (Array.isArray(value)) {{
            value.forEach(v => params.append(key, String(v)));
          }} else {{
            params.append(key, String(value));
          }}
        }}
      }});

      const queryString = params.toString();
      if (queryString) {{
        url += `?${{queryString}}`;
      }}
    }}

    return url;
  }}

  private async buildHeaders(
    method: string,
    customHeaders?: Record<string, string>,
    isFileUpload?: boolean,
    requiresAuth?: boolean
  ): Promise<HeadersInit> {{
    const headers: Record<string, string> = {{
      ...this.config.headers,
      ...customHeaders,
    }};

    // Don't set Content-Type for file uploads (browser sets with boundary)
    if (!isFileUpload && !headers['Content-Type']) {{
      headers['Content-Type'] = 'application/json';
    }}

{(includeAuth ? @"
    // Add authentication token
    if (requiresAuth !== false && this.config.auth?.getAccessToken) {{
      const token = await Promise.resolve(this.config.auth.getAccessToken());
      if (token) {{
        headers['Authorization'] = `Bearer ${{token}}`;
      }}
    }}

    // Add session ID if available
    if (this.sessionId) {{
      headers['X-Session-Id'] = this.sessionId;
    }}
" : "")}
{(includeCsrf ? @"
    // Add CSRF token for state-changing requests
    if (['POST', 'PUT', 'PATCH', 'DELETE'].includes(method.toUpperCase())) {{
      const csrfToken = await this.csrfManager.getToken();
      if (csrfToken) {{
        headers['X-CSRF-Token'] = csrfToken;
      }}
    }}
" : "")}
    return headers;
  }}

  private async handleErrorResponse(response: Response): Promise<never> {{
    const contentType = response.headers.get('Content-Type');
    
    // Handle RFC 7807 Problem Details
    if (contentType?.includes('application/problem+json')) {{
      const problemDetails: ProblemDetails = await response.json();
      throw new HttpClientError(
        problemDetails.title ?? problemDetails.detail ?? 'Request failed',
        response.status,
        problemDetails,
        response
      );
    }}

    // Handle standard JSON errors
    if (contentType?.includes('application/json')) {{
      const errorData = await response.json();
      throw new HttpClientError(
        errorData.message ?? errorData.error ?? 'Request failed',
        response.status,
        undefined,
        response
      );
    }}

    // Fallback to status text
    throw new HttpClientError(
      response.statusText || 'Request failed',
      response.status,
      undefined,
      response
    );
  }}

  private extractFilename(response: Response): string | undefined {{
    const disposition = response.headers.get('Content-Disposition');
    if (!disposition) return undefined;

    const filenameMatch = disposition.match(/filename[^;=\\n]*=((['\""]).*?\\2|[^;\\n]*)/);
    if (!filenameMatch) return undefined;

    let filename = filenameMatch[1].trim();
    // Remove quotes if present
    if (filename.startsWith('""') || filename.startsWith(""'"")) {{
      filename = filename.slice(1, -1);
    }}

    return filename;
  }}

{(includeAuth ? @"
  /**
   * Refreshes the authentication token with retry protection.
   * Includes cooldown period and max attempts to prevent token refresh storms.
   */
  private async refreshToken(): Promise<boolean> {{
    // Check cooldown period
    const now = Date.now();
    if (now - this.lastRefreshAttempt < this.refreshCooldownMs) {{
      console.warn('Token refresh in cooldown period');
      return false;
    }}

    // Check max attempts
    if (this.refreshAttemptCount >= this.maxRefreshAttempts) {{
      console.error('Max token refresh attempts exceeded');
      this.refreshAttemptCount = 0; // Reset for next window
      return false;
    }}

    // Reuse existing refresh promise to prevent concurrent refreshes
    if (this.refreshPromise) {{
      await this.refreshPromise;
      return this.config.auth?.getAccessToken !== undefined;
    }}

    this.lastRefreshAttempt = now;
    this.refreshAttemptCount++;

    this.refreshPromise = (async () => {{
      try {{
        const refreshToken = await this.config.auth?.getRefreshToken?.();
        if (!refreshToken || !this.config.auth?.refreshEndpoint) {{
          return;
        }}

        const response = await fetch(
          `${{this.config.baseUrl}}${{this.config.auth.refreshEndpoint}}`,
          {{
            method: 'POST',
            headers: {{ 'Content-Type': 'application/json' }},
            body: JSON.stringify({{ refreshToken }}),
            credentials: 'include',
          }}
        );

        if (!response.ok) {{
          console.error('Token refresh failed:', response.statusText);
          return;
        }}

        const data = await response.json();
        const newAccessToken = data.accessToken ?? data.token;
        const newRefreshToken = data.refreshToken;

        if (newAccessToken) {{
          await this.config.auth?.onTokenRefreshed?.(newAccessToken, newRefreshToken);
          
          // Extract and update session ID
          if (this.config.auth?.extractSessionId) {{
            this.sessionId = this.extractSessionIdFromToken(newAccessToken);
          }}

          // Reset attempt count on success
          this.refreshAttemptCount = 0;
        }}
      }} catch (error) {{
        console.error('Error refreshing token:', error);
      }} finally {{
        this.refreshPromise = null;
      }}
    }})();

    await this.refreshPromise;
    return this.config.auth?.getAccessToken !== undefined;
  }}

  /**
   * Extracts session ID from JWT token payload.
   * Expects a 'sessionId' or 'sid' claim in the token.
   */
  private extractSessionIdFromToken(token: string): string | null {{
    try {{
      const parts = token.split('.');
      if (parts.length !== 3) return null;

      const payload = JSON.parse(atob(parts[1]));
      return payload.sessionId ?? payload.sid ?? null;
    }} catch (error) {{
      console.error('Error extracting session ID from token:', error);
      return null;
    }}
  }}
" : "")}
  get<TResponse = any>(path: string, options?: {{
    headers?: Record<string, string>;
    queryParams?: Record<string, any>;
    requiresAuth?: boolean;
  }}): Promise<TResponse> {{
    return this.request<TResponse>('GET', path, options);
  }}

  post<TResponse = any, TBody = any>(path: string, body?: TBody, options?: {{
    headers?: Record<string, string>;
    requiresAuth?: boolean;
    isFileUpload?: boolean;
  }}): Promise<TResponse> {{
    return this.request<TResponse>('POST', path, {{ ...options, body }});
  }}

  put<TResponse = any, TBody = any>(path: string, body?: TBody, options?: {{
    headers?: Record<string, string>;
    requiresAuth?: boolean;
  }}): Promise<TResponse> {{
    return this.request<TResponse>('PUT', path, {{ ...options, body }});
  }}

  patch<TResponse = any, TBody = any>(path: string, body?: TBody, options?: {{
    headers?: Record<string, string>;
    requiresAuth?: boolean;
  }}): Promise<TResponse> {{
    return this.request<TResponse>('PATCH', path, {{ ...options, body }});
  }}

  delete<TResponse = any>(path: string, options?: {{
    headers?: Record<string, string>;
    requiresAuth?: boolean;
  }}): Promise<TResponse> {{
    return this.request<TResponse>('DELETE', path, options);
  }}
}}

// Singleton instance
let httpClientInstance: HttpClient | null = null;

export function configureSdk(config: HttpClientConfig): void {{
  httpClientInstance = new HttpClient(config);
}}

export function getHttpClient(): HttpClient {{
  if (!httpClientInstance) {{
    throw new Error('SDK not configured. Call configureSdk() first.');
  }}
  return httpClientInstance;
}}
";
    }

    private static string GetFileOperationsTemplate()
    {
        return @"
/**
 * Creates FormData from files and additional data for file uploads.
 * @param files - Single file or array of files to upload
 * @param additionalData - Additional form fields to include
 * @returns FormData ready for upload
 */
export function createFormData(
  files: File | File[],
  additionalData?: Record<string, any>
): FormData {
  const formData = new FormData();

  // Add files
  const fileArray = Array.isArray(files) ? files : [files];
  fileArray.forEach((file, index) => {
    formData.append('files', file, file.name);
  });

  // Add additional data
  if (additionalData) {
    Object.entries(additionalData).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        if (typeof value === 'object' && !(value instanceof File)) {
          formData.append(key, JSON.stringify(value));
        } else {
          formData.append(key, String(value));
        }
      }
    });
  }

  return formData;
}

/**
 * Downloads a file from the specified URL.
 * @param path - API path to download file from
 * @param filename - Optional custom filename (overrides server-provided name)
 * @returns FileResult with blob data and metadata
 */
export async function downloadFile(
  path: string,
  filename?: string
): Promise<FileResult> {
  const client = getHttpClient();
  const result = await client.request<FileResult>('GET', path, {
    isFileDownload: true,
    requiresAuth: true,
  });

  return {
    ...result,
    filename: filename ?? result.filename,
  };
}

/**
 * Triggers a browser download for a file result.
 * Creates a temporary <a> element to initiate the download.
 * @param fileResult - The file result to download
 * @param customFilename - Optional custom filename (overrides result filename)
 */
export function triggerFileDownload(
  fileResult: FileResult,
  customFilename?: string
): void {
  const blob = fileResult.data;
  const url = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = customFilename ?? fileResult.filename ?? 'download';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  window.URL.revokeObjectURL(url);
}
";
    }
}
