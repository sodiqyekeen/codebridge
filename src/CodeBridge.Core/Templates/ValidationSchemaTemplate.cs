using System.Text;
using CodeBridge.Core.Models;

namespace CodeBridge.Core.Templates;

/// <summary>
/// Generates TypeScript validation schemas from FluentValidation rules.
/// Produces type-safe validation functions that mirror C# FluentValidation behavior.
/// </summary>
public static class ValidationSchemaTemplate
{
    public static string GenerateValidationSchema(
        List<TypeInfo> types,
        List<ValidationRule> validationRules)
    {
        var sb = new StringBuilder();

        // Header
        sb.AppendLine("// Auto-generated Validation Schemas");
        sb.AppendLine("// DO NOT EDIT - This file is generated by CodeBridge");
        sb.AppendLine();

        // Type definitions
        sb.AppendLine("export interface ValidationError {");
        sb.AppendLine("  field: string;");
        sb.AppendLine("  message: string;");
        sb.AppendLine("  rule?: string;");
        sb.AppendLine("}");
        sb.AppendLine();

        sb.AppendLine("export interface ValidationResult {");
        sb.AppendLine("  isValid: boolean;");
        sb.AppendLine("  errors: ValidationError[];");
        sb.AppendLine("}");
        sb.AppendLine();

        // Group validation rules by type
        var rulesByType = validationRules
            .GroupBy(r => r.TypeName)
            .ToDictionary(g => g.Key, g => g.ToList());

        // Generate validation function for each type that has rules
        foreach (var type in types.Where(t => rulesByType.ContainsKey(t.Name)))
        {
            var rules = rulesByType[type.Name];
            GenerateValidationFunction(sb, type, rules);
            sb.AppendLine();
        }

        // Generate generic helper functions
        GenerateHelperFunctions(sb);

        return sb.ToString();
    }

    private static void GenerateValidationFunction(
        StringBuilder sb,
        TypeInfo type,
        List<ValidationRule> rules)
    {
        sb.AppendLine($"/**");
        sb.AppendLine($" * Validates {type.Name} data against FluentValidation rules.");
        sb.AppendLine($" * @param data - Partial or complete {type.Name} object to validate");
        sb.AppendLine($" * @returns Validation result with errors if any");
        sb.AppendLine($" */");
        sb.AppendLine($"export function validate{type.Name}(");
        sb.AppendLine($"  data: Partial<{type.Name}>");
        sb.AppendLine("): ValidationResult {");
        sb.AppendLine("  const errors: ValidationError[] = [];");
        sb.AppendLine();

        // Group rules by property
        var rulesByProperty = rules.GroupBy(r => r.PropertyName);

        foreach (var propertyRules in rulesByProperty)
        {
            var propertyName = ToCamelCase(propertyRules.Key);
            var property = type.Properties.FirstOrDefault(p =>
                p.Name.Equals(propertyRules.Key, StringComparison.OrdinalIgnoreCase));

            sb.AppendLine($"  // Validation for {propertyName}");

            foreach (var rule in propertyRules)
            {
                GenerateValidationCheck(sb, propertyName, property, rule);
            }

            sb.AppendLine();
        }

        sb.AppendLine("  return { isValid: errors.length === 0, errors };");
        sb.AppendLine("}");
    }

    private static void GenerateValidationCheck(
        StringBuilder sb,
        string propertyName,
        PropertyInfo? property,
        ValidationRule rule)
    {
        var errorMessage = rule.ErrorMessage ?? GetDefaultErrorMessage(propertyName, rule.RuleType, rule.Value);

        switch (rule.RuleType.ToLowerInvariant())
        {
            case "required":
            case "notempty":
            case "notnull":
                sb.AppendLine($"  if (data.{propertyName} === undefined || data.{propertyName} === null || data.{propertyName} === '') {{");
                sb.AppendLine($"    errors.push({{ field: '{propertyName}', message: '{EscapeString(errorMessage)}', rule: 'required' }});");
                sb.AppendLine("  }");
                break;

            case "email":
            case "emailaddress":
                sb.AppendLine($"  if (data.{propertyName} && !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(String(data.{propertyName}))) {{");
                sb.AppendLine($"    errors.push({{ field: '{propertyName}', message: '{EscapeString(errorMessage)}', rule: 'email' }});");
                sb.AppendLine("  }");
                break;

            case "minlength":
            case "minimumlength":
                sb.AppendLine($"  if (data.{propertyName} && String(data.{propertyName}).length < {rule.Value}) {{");
                sb.AppendLine($"    errors.push({{ field: '{propertyName}', message: '{EscapeString(errorMessage)}', rule: 'minLength' }});");
                sb.AppendLine("  }");
                break;

            case "maxlength":
            case "maximumlength":
                sb.AppendLine($"  if (data.{propertyName} && String(data.{propertyName}).length > {rule.Value}) {{");
                sb.AppendLine($"    errors.push({{ field: '{propertyName}', message: '{EscapeString(errorMessage)}', rule: 'maxLength' }});");
                sb.AppendLine("  }");
                break;

            case "length":
                // Length rule can have both min and max
                if (rule.Metadata != null)
                {
                    if (rule.Metadata.TryGetValue("min", out var min) && rule.Metadata.TryGetValue("max", out var max))
                    {
                        sb.AppendLine($"  if (data.{propertyName}) {{");
                        sb.AppendLine($"    const len = String(data.{propertyName}).length;");
                        sb.AppendLine($"    if (len < {min} || len > {max}) {{");
                        sb.AppendLine($"      errors.push({{ field: '{propertyName}', message: '{EscapeString(errorMessage)}', rule: 'length' }});");
                        sb.AppendLine("    }");
                        sb.AppendLine("  }");
                    }
                }
                break;

            case "pattern":
            case "matches":
            case "regex":
                var pattern = rule.Value?.ToString() ?? "";
                // Escape regex for JavaScript
                pattern = pattern.Replace("\\", "\\\\").Replace("'", "\\'");
                sb.AppendLine($"  if (data.{propertyName} && !/{pattern}/.test(String(data.{propertyName}))) {{");
                sb.AppendLine($"    errors.push({{ field: '{propertyName}', message: '{EscapeString(errorMessage)}', rule: 'pattern' }});");
                sb.AppendLine("  }");
                break;

            case "min":
            case "greaterthan":
                var isExclusiveMin = rule.Metadata?.ContainsKey("exclusive") == true &&
                                    Convert.ToBoolean(rule.Metadata["exclusive"]);
                var minOperator = isExclusiveMin ? "<=" : "<";
                sb.AppendLine($"  if (data.{propertyName} != null && Number(data.{propertyName}) {minOperator} {rule.Value}) {{");
                sb.AppendLine($"    errors.push({{ field: '{propertyName}', message: '{EscapeString(errorMessage)}', rule: 'min' }});");
                sb.AppendLine("  }");
                break;

            case "max":
            case "lessthan":
                var isExclusiveMax = rule.Metadata?.ContainsKey("exclusive") == true &&
                                    Convert.ToBoolean(rule.Metadata["exclusive"]);
                var maxOperator = isExclusiveMax ? ">=" : ">";
                sb.AppendLine($"  if (data.{propertyName} != null && Number(data.{propertyName}) {maxOperator} {rule.Value}) {{");
                sb.AppendLine($"    errors.push({{ field: '{propertyName}', message: '{EscapeString(errorMessage)}', rule: 'max' }});");
                sb.AppendLine("  }");
                break;

            case "range":
                if (rule.Metadata != null &&
                    rule.Metadata.TryGetValue("min", out var rangeMin) &&
                    rule.Metadata.TryGetValue("max", out var rangeMax))
                {
                    sb.AppendLine($"  if (data.{propertyName} != null) {{");
                    sb.AppendLine($"    const val = Number(data.{propertyName});");
                    sb.AppendLine($"    if (val < {rangeMin} || val > {rangeMax}) {{");
                    sb.AppendLine($"      errors.push({{ field: '{propertyName}', message: '{EscapeString(errorMessage)}', rule: 'range' }});");
                    sb.AppendLine("    }");
                    sb.AppendLine("  }");
                }
                break;

            case "creditcard":
                sb.AppendLine($"  if (data.{propertyName} && !isValidCreditCard(String(data.{propertyName}))) {{");
                sb.AppendLine($"    errors.push({{ field: '{propertyName}', message: '{EscapeString(errorMessage)}', rule: 'creditCard' }});");
                sb.AppendLine("  }");
                break;

            case "url":
                sb.AppendLine($"  if (data.{propertyName}) {{");
                sb.AppendLine("    try {");
                sb.AppendLine($"      new URL(String(data.{propertyName}));");
                sb.AppendLine("    } catch {");
                sb.AppendLine($"      errors.push({{ field: '{propertyName}', message: '{EscapeString(errorMessage)}', rule: 'url' }});");
                sb.AppendLine("    }");
                sb.AppendLine("  }");
                break;

            case "equal":
            case "equals":
                sb.AppendLine($"  if (data.{propertyName} !== {FormatValue(rule.Value)}) {{");
                sb.AppendLine($"    errors.push({{ field: '{propertyName}', message: '{EscapeString(errorMessage)}', rule: 'equal' }});");
                sb.AppendLine("  }");
                break;

            case "notequal":
                sb.AppendLine($"  if (data.{propertyName} === {FormatValue(rule.Value)}) {{");
                sb.AppendLine($"    errors.push({{ field: '{propertyName}', message: '{EscapeString(errorMessage)}', rule: 'notEqual' }});");
                sb.AppendLine("  }");
                break;
        }
    }

    private static void GenerateHelperFunctions(StringBuilder sb)
    {
        sb.AppendLine("// Helper functions");
        sb.AppendLine();

        // Credit card validation using Luhn algorithm
        sb.AppendLine("/**");
        sb.AppendLine(" * Validates credit card number using Luhn algorithm.");
        sb.AppendLine(" */");
        sb.AppendLine("function isValidCreditCard(cardNumber: string): boolean {");
        sb.AppendLine("  const digits = cardNumber.replace(/\\D/g, '');");
        sb.AppendLine("  if (digits.length < 13 || digits.length > 19) return false;");
        sb.AppendLine();
        sb.AppendLine("  let sum = 0;");
        sb.AppendLine("  let isEven = false;");
        sb.AppendLine();
        sb.AppendLine("  for (let i = digits.length - 1; i >= 0; i--) {");
        sb.AppendLine("    let digit = parseInt(digits[i], 10);");
        sb.AppendLine();
        sb.AppendLine("    if (isEven) {");
        sb.AppendLine("      digit *= 2;");
        sb.AppendLine("      if (digit > 9) digit -= 9;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    sum += digit;");
        sb.AppendLine("    isEven = !isEven;");
        sb.AppendLine("  }");
        sb.AppendLine();
        sb.AppendLine("  return sum % 10 === 0;");
        sb.AppendLine("}");
    }

    private static string GetDefaultErrorMessage(string propertyName, string ruleType, object? value)
    {
        return ruleType.ToLowerInvariant() switch
        {
            "required" or "notempty" or "notnull" => $"{propertyName} is required",
            "email" or "emailaddress" => $"{propertyName} must be a valid email address",
            "minlength" or "minimumlength" => $"{propertyName} must be at least {value} characters",
            "maxlength" or "maximumlength" => $"{propertyName} must not exceed {value} characters",
            "pattern" or "matches" or "regex" => $"{propertyName} format is invalid",
            "min" or "greaterthan" => $"{propertyName} must be greater than {value}",
            "max" or "lessthan" => $"{propertyName} must be less than {value}",
            "range" => $"{propertyName} must be within the specified range",
            "creditcard" => $"{propertyName} must be a valid credit card number",
            "url" => $"{propertyName} must be a valid URL",
            "equal" or "equals" => $"{propertyName} must equal {value}",
            "notequal" => $"{propertyName} must not equal {value}",
            _ => $"{propertyName} is invalid"
        };
    }

    private static string FormatValue(object? value)
    {
        if (value == null) return "null";
        if (value is string str) return $"'{EscapeString(str)}'";
        if (value is bool b) return b.ToString().ToLowerInvariant();
        return value.ToString() ?? "null";
    }

    private static string EscapeString(string str)
    {
        return str
            .Replace("\\", "\\\\")
            .Replace("'", "\\'")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t");
    }

    private static string ToCamelCase(string value)
    {
        if (string.IsNullOrEmpty(value) || char.IsLower(value[0]))
            return value;

        return char.ToLowerInvariant(value[0]) + value[1..];
    }
}
